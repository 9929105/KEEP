// Generated by CoffeeScript 1.6.1
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(['jquery', 'vendor/underscore', 'vendor/backbone-min', 'leaflet', 'leaflet_heatmap', 'leaflet_cluster'], function($, _, Backbone, L) {
  var MapView,
    _this = this;
  MapView = (function(_super) {

    __extends(MapView, _super);

    function MapView() {
      var _this = this;
      this.auto_step = function(event) {
        return MapView.prototype.auto_step.apply(_this, arguments);
      };
      return MapView.__super__.constructor.apply(this, arguments);
    }

    MapView.prototype.name = "MapView";

    MapView.prototype.el = $('#map_viz');

    MapView.prototype.btn = $('#map_btn');

    MapView.prototype.map_headers = void 0;

    MapView.prototype.map = void 0;

    MapView.prototype.events = {
      "change #fps": "update_fps",
      "change #playtime": "update_playtime",
      "change #progress_bar": "update_progress",
      "click #time_step a.btn": "time_step",
      "click #auto_step a.btn": "auto_step",
      "click #time_static a.btn": "time_static",
      "click #pause a.btn": "pause_playback",
      "click #reset": "reset_playback",
      "click #time_c": "time_c",
      "click #clear": "clear_lines"
    };

    MapView.prototype.initialize = function(options) {
      this.parent = options.parent;
      this.data = options.data;
      this.form = options.form;
      this._detect_headers(this.form.attributes.children);
      if (this.map_headers != null) {
        this.btn.removeClass('disabled');
        return this.render();
      }
    };

    MapView.prototype._detect_headers = function(root) {
      var field, _i, _len, _ref, _ref1;
      for (_i = 0, _len = root.length; _i < _len; _i++) {
        field = root[_i];
        if ((_ref = field.type) === 'group') {
          this._detect_headers(field.children);
        }
        if ((_ref1 = field.type) === 'geopoint') {
          this.map_headers = field;
          return;
        }
      }
    };

    MapView.prototype.render = function() {
      var center, constrainedMarker, controls, datum, geopoint, heatmapData, html, key, layers, marker, myIcon, valid_count, value, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      this.heatmap = L.TileLayer.heatMap({
        radius: 80,
        opacity: 0.8,
        gradient: {
          0.45: "rgb(0,0,255)",
          0.55: "rgb(0,255,255)",
          0.65: "rgb(0,255,0)",
          0.95: "yellow",
          1.0: "rgb(255,0,0)"
        }
      });
      center = [0, 0];
      valid_count = 0;
      _ref = this.data.models;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        datum = _ref[_i];
        geopoint = datum.get('data')[this.map_headers.name];
        if (geopoint == null) {
          continue;
        }
        geopoint = geopoint.split(' ');
        if (isNaN(geopoint[0]) || isNaN(geopoint[1])) {
          continue;
        }
        center[0] += parseFloat(geopoint[0]);
        center[1] += parseFloat(geopoint[1]);
        valid_count += 1;
      }
      if (valid_count === 0) {
        this.map_enabled = false;
        $('#map_btn').addClass('disabled');
        $('#map').hide();
        return this;
      }
      center[0] = center[0] / valid_count;
      center[1] = center[1] / valid_count;
      this.map = L.map('map').setView(center, 10);
      L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors',
        maxZoom: 18
      }).addTo(this.map);
      myIcon = L.icon({
        iconUrl: '//keep-static.s3.amazonaws.com/img/leaflet/marker-icon.png',
        iconRetinaUrl: '//keep-static.s3.amazonaws.com/img/leaflet/marker-icon@2x.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowUrl: '//keep-static.s3.amazonaws.com/img/leaflet/marker-shadow.png',
        shadowSize: [41, 41],
        shadowAnchor: [15, 41]
      });
      heatmapData = [];
      this.markers = [];
      this.constrained_markers = [];
      this.marker_layer = new L.MarkerClusterGroup();
      _ref1 = this.data.models;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        datum = _ref1[_j];
        geopoint = datum.get('data')[this.map_headers.name];
        if (geopoint == null) {
          continue;
        }
        geopoint = geopoint.split(' ');
        if (isNaN(geopoint[0]) || isNaN(geopoint[1])) {
          continue;
        }
        marker = L.marker([geopoint[0], geopoint[1]], {
          icon: myIcon
        });
        html = '';
        _ref2 = datum.get('data');
        for (key in _ref2) {
          value = _ref2[key];
          html += "<div><strong>" + key + ":</strong> " + value + "</div>";
        }
        marker.bindPopup(html);
        this.marker_layer.addLayer(marker);
        constrainedMarker = L.marker([geopoint[0], geopoint[1]], {
          icon: myIcon
        });
        heatmapData.push({
          lat: geopoint[0],
          lon: geopoint[1],
          value: 1
        });
      }
      this.constrained_layer = L.layerGroup(this.constrained_markers);
      this.heatmap.addData(heatmapData);
      this.map.addLayer(this.heatmap);
      this.map.addLayer(this.marker_layer);
      layers = {
        'Markers': this.marker_layer,
        'Heatmap': this.heatmap
      };
      controls = L.control.layers(null, layers, {
        collapsed: false
      });
      controls.addTo(this.map);
      return this;
    };

    MapView.prototype.auto_step = function(event) {
      var auto,
        _this = this;
      auto = function() {
        if (!_this.is_paused) {
          return _this.time_step();
        }
      };
      return this.playback = setInterval(auto, 1000 / fps.value);
    };

    MapView.prototype.pause_playback = function(event) {
      if (this.is_paused) {
        $('#pause_btn').html('Pause');
        return this.is_paused = false;
      } else {
        $('#pause_btn').html('Resume');
        return this.is_paused = true;
      }
    };

    MapView.prototype.reset_playback = function(event) {
      var i;
      this.reset = true;
      this.step_current = 0;
      this.num_steps = 0;
      this.quantum = 0;
      this.min_time = 0;
      this.max_time = 0;
      this.lower_bound = 0;
      this.upper_bound = 0;
      current_time.innerHTML = "";
      this.progress = 0;
      progress_bar.value = 0;
      pause_btn.innerHTML = "Pause";
      this.is_paused = false;
      clearInterval(this.playback);
      this.playback = null;
      for (i in this.map._layers) {
        if (this.map._layers[i]._path !== undefined) {
          try {
            this.map.removeLayer(this.map._layers[i]);
          } catch (e) {
            console.log("problem with " + e + this.map._layers[i]);
          }
        }
      }
      return this.renderMap();
    };

    MapView.prototype.time_static = function(event) {
      var length;
      this.step_clicked = true;
      length = this.data.models.length;
      this.min_time = Date.parse(this.data.models[0].get('timestamp'));
      this.max_time = Date.parse(this.data.models[length - 1].get('timestamp'));
      if (start_date.value !== "") {
        this.min_time = Date.parse(start_date.value);
      }
      if (end_date.value !== "") {
        this.max_time = Date.parse(end_date.value);
      }
      this.lower_bound = this.min_time;
      this.upper_bound = this.max_time;
      return this.renderMap();
    };

    MapView.prototype.update_fps = function() {
      $('#fpsbox').html(fps.value);
      return this;
    };

    MapView.prototype.update_playtime = function() {
      $('#playtimebox').html(playtime.value);
      return this;
    };

    MapView.prototype.update_progress = function() {
      if (this.step_clicked === true && this.reset === false) {
        if (this.is_paused === false) {
          this.is_paused = true;
        }
        this.progress = progress_bar.value;
        this.upper_bound = this.progress / this.progress_range * (this.max_time - this.min_time) + this.min_time;
        if (cumulativeCheck.checked === true) {
          this.lower_bound = this.min_time;
        } else {
          this.lower_bound = this.upper_bound - this.quantum;
        }
        current_time.innerHTML = new Date(this.lower_bound) + " through " + new Date(this.upper_bound);
        this.is_paused = false;
        return this.renderMap();
      }
    };

    MapView.prototype.clear_lines = function(event) {
      var i, _results;
      _results = [];
      for (i in this.map._layers) {
        if (this.map._layers[i]._path !== undefined) {
          try {
            _results.push(this.map.removeLayer(this.map._layers[i]));
          } catch (e) {
            _results.push(console.log("problem with " + e + this.map._layers[i]));
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    MapView.prototype.time_step = function(event) {
      var length;
      if (this.step_clicked === false || this.reset === true) {
        length = this.data.models.length;
        this.step_clicked = true;
        this.reset = false;
        this.min_time = Date.parse(this.data.models[0].get('timestamp'));
        this.max_time = Date.parse(this.data.models[length - 1].get('timestamp'));
        if (start_date.value !== "") {
          this.min_time = Date.parse(start_date.value);
        }
        if (end_date.value !== "") {
          this.max_time = Date.parse(end_date.value);
        }
        this.num_steps = fps.value * playtime.value;
        this.quantum = Math.floor((this.max_time - this.min_time) / this.num_steps);
        this.lower_bound = this.min_time;
        this.upper_bound = this.min_time + this.quantum;
      }
      this.step_current += 1;
      if (this.step_current <= this.num_steps) {
        this.renderMap();
        current_time.innerHTML = new Date(this.lower_bound) + " through " + new Date(this.upper_bound);
        this.progress = this.progress_range * ((this.upper_bound - this.min_time) / (this.max_time - this.min_time));
        progress_bar.value = this.progress;
      }
      if (cumulativeCheck.checked === false) {
        this.lower_bound += this.quantum;
      }
      return this.upper_bound += this.quantum;
    };

    MapView.prototype.time_c = function(event) {
      var con, d, d2, datum, datum2, days, geopoint, hours, i, minutes, parseDate, secs, start, start2, time, val, _j, _k, _len1, _ref5, _results;
      val = $("#tc_input").val();
      con = $("input:radio[name=const]:checked").val();
      time = $("input:radio[name=time]:checked").val();
      minutes = 1000 * 60;
      hours = minutes * 60;
      days = hours * 24;
      secs = void 0;
      for (i in this.map._layers) {
        if (this.map._layers[i]._path !== undefined) {
          try {
            this.map.removeLayer(this.map._layers[i]);
          } catch (e) {
            console.log("problem with " + e + this.map._layers[i]);
          }
        }
      }
      if (con === "day") {
        secs = days;
      } else if (con === "hour") {
        secs = hours;
      } else {
        if (con === "minute") {
          secs = minutes;
        }
      }
      _ref5 = this.data.models;
      _j = 0;
      _len1 = _ref5.length;
      _results = [];
      while (_j < (_len1 - 1)) {
        datum = _ref5[_j];
        parseDate = d3.time.format("%Y-%m-%dT%H:%M:%S").parse;
        if (time === "date") {
          try {
            start = Date.parse(this.data.models[_j].attributes.data.Time);
          } catch (err) {
            start = null;
          }
        } else {
          start = parseDate(this.data.models[_j].get("timestamp"));
        }
        d = Math.floor(start / secs);
        geopoint = datum.get("data")[this.map_headers].split(" ");
        this.pL = [];
        this.pL.push([parseFloat(geopoint[0]), parseFloat(geopoint[1])]);
        _k = _j + 1;
        _len1 = _ref5.length;
        while (_k < _len1) {
          if (start = null) {
            break;
          }
          datum2 = _ref5[_k];
          parseDate = d3.time.format("%Y-%m-%dT%H:%M:%S").parse;
          if (time === "date") {
            try {
              start2 = Date.parse(this.data.models[_k].attributes.data.Time);
            } catch (err) {
              start2 = null;
            }
          } else {
            start2 = parseDate(this.data.models[_k].get("timestamp"));
          }
          d2 = Math.floor(start2 / secs);
          geopoint = datum2.get("data")[this.map_headers].split(" ");
          if (val >= Math.abs(d - d2)) {
            this.pL.push([parseFloat(geopoint[0]), parseFloat(geopoint[1])]);
            this.poly = L.polyline(this.pL, this.pLStyle).addTo(this.map);
          } else {
            break;
          }
          _k++;
        }
        _results.push(_j++);
      }
      return _results;
    };

    return MapView;

  })(Backbone.View);
  return MapView;
});
